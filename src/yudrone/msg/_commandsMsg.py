"""autogenerated by genpy from yudrone/commandsMsg.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg
import std_msgs.msg

class commandsMsg(genpy.Message):
  _md5sum = "35dbbcc6aa4842e9ba719e959ccc6b35"
  _type = "yudrone/commandsMsg"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header header

#*****************************************************************************
# This file contains message description to send different commands.
# Different purposes are enabled by setting hasXYZ to True.
#*****************************************************************************
# Project:	yudrone
# Author:	Michael Dicke
# Repository:	https://github.com/mdicke2s/yudrone
#*****************************************************************************

# publishes Twist msg ********************************************************
bool hasTwist
geometry_msgs/Twist twist

# Altitude(self, delta) ******************************************************
bool hasAltd
int32 altd

# MaxAltd(self, val) *********************************************************
bool hasMaxAltd
int32 MaxAltd

# MinAltd(self, val) *********************************************************
bool hasMinAltd
int32 MixAltd
      
# Yaw(self, angle) ***********************************************************
bool hasYaw
int32 yaw

# Horizontal(self, x, y) *****************************************************
bool hasHorizontal
int32 horizontalX
int32 horizontalY

# Face(self, tagNr, faceYaw = True, faceDist = True, faceAlt = True,  ********
# facePerpend = True, keepSearching = False) 
bool hasFace
int32 tagNr

# Release(self) **************************************************************
bool hasRelease

# Search(self, tagNr) ********************************************************
bool hasSearch
# int32 tagNr already defined

# Approach(self, tagNr) ******************************************************
bool hasApproach
# int32 tagNr already defined

# Navigate(self, x, y, z, xRot, yRot, zRot) **********************************
bool hasNavigate
int32[] nav_XYZ_RxRyRz

# YawSpeed(self, val) ********************************************************
bool hasYawSpeed
int32 yawSpeed

# HrzSpeed(self, val) ********************************************************
bool hasHrzSpeed
int32 hrzSpeed

# not implemented by now...
# TakeOff(self): Land(self): ToggleEmerg(self) *******************************
# __reset_twist(self, delay = 0) *********************************************


================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into it's linear and angular parts. 
Vector3  linear
Vector3  angular

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 

float64 x
float64 y
float64 z
"""
  __slots__ = ['header','hasTwist','twist','hasAltd','altd','hasMaxAltd','MaxAltd','hasMinAltd','MixAltd','hasYaw','yaw','hasHorizontal','horizontalX','horizontalY','hasFace','tagNr','hasRelease','hasSearch','hasApproach','hasNavigate','nav_XYZ_RxRyRz','hasYawSpeed','yawSpeed','hasHrzSpeed','hrzSpeed']
  _slot_types = ['std_msgs/Header','bool','geometry_msgs/Twist','bool','int32','bool','int32','bool','int32','bool','int32','bool','int32','int32','bool','int32','bool','bool','bool','bool','int32[]','bool','int32','bool','int32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,hasTwist,twist,hasAltd,altd,hasMaxAltd,MaxAltd,hasMinAltd,MixAltd,hasYaw,yaw,hasHorizontal,horizontalX,horizontalY,hasFace,tagNr,hasRelease,hasSearch,hasApproach,hasNavigate,nav_XYZ_RxRyRz,hasYawSpeed,yawSpeed,hasHrzSpeed,hrzSpeed

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(commandsMsg, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.hasTwist is None:
        self.hasTwist = False
      if self.twist is None:
        self.twist = geometry_msgs.msg.Twist()
      if self.hasAltd is None:
        self.hasAltd = False
      if self.altd is None:
        self.altd = 0
      if self.hasMaxAltd is None:
        self.hasMaxAltd = False
      if self.MaxAltd is None:
        self.MaxAltd = 0
      if self.hasMinAltd is None:
        self.hasMinAltd = False
      if self.MixAltd is None:
        self.MixAltd = 0
      if self.hasYaw is None:
        self.hasYaw = False
      if self.yaw is None:
        self.yaw = 0
      if self.hasHorizontal is None:
        self.hasHorizontal = False
      if self.horizontalX is None:
        self.horizontalX = 0
      if self.horizontalY is None:
        self.horizontalY = 0
      if self.hasFace is None:
        self.hasFace = False
      if self.tagNr is None:
        self.tagNr = 0
      if self.hasRelease is None:
        self.hasRelease = False
      if self.hasSearch is None:
        self.hasSearch = False
      if self.hasApproach is None:
        self.hasApproach = False
      if self.hasNavigate is None:
        self.hasNavigate = False
      if self.nav_XYZ_RxRyRz is None:
        self.nav_XYZ_RxRyRz = []
      if self.hasYawSpeed is None:
        self.hasYawSpeed = False
      if self.yawSpeed is None:
        self.yawSpeed = 0
      if self.hasHrzSpeed is None:
        self.hasHrzSpeed = False
      if self.hrzSpeed is None:
        self.hrzSpeed = 0
    else:
      self.header = std_msgs.msg.Header()
      self.hasTwist = False
      self.twist = geometry_msgs.msg.Twist()
      self.hasAltd = False
      self.altd = 0
      self.hasMaxAltd = False
      self.MaxAltd = 0
      self.hasMinAltd = False
      self.MixAltd = 0
      self.hasYaw = False
      self.yaw = 0
      self.hasHorizontal = False
      self.horizontalX = 0
      self.horizontalY = 0
      self.hasFace = False
      self.tagNr = 0
      self.hasRelease = False
      self.hasSearch = False
      self.hasApproach = False
      self.hasNavigate = False
      self.nav_XYZ_RxRyRz = []
      self.hasYawSpeed = False
      self.yawSpeed = 0
      self.hasHrzSpeed = False
      self.hrzSpeed = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_B6dBiBiBiBiB2iBi4B.pack(_x.hasTwist, _x.twist.linear.x, _x.twist.linear.y, _x.twist.linear.z, _x.twist.angular.x, _x.twist.angular.y, _x.twist.angular.z, _x.hasAltd, _x.altd, _x.hasMaxAltd, _x.MaxAltd, _x.hasMinAltd, _x.MixAltd, _x.hasYaw, _x.yaw, _x.hasHorizontal, _x.horizontalX, _x.horizontalY, _x.hasFace, _x.tagNr, _x.hasRelease, _x.hasSearch, _x.hasApproach, _x.hasNavigate))
      length = len(self.nav_XYZ_RxRyRz)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.nav_XYZ_RxRyRz))
      _x = self
      buff.write(_struct_BiBi.pack(_x.hasYawSpeed, _x.yawSpeed, _x.hasHrzSpeed, _x.hrzSpeed))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.twist is None:
        self.twist = geometry_msgs.msg.Twist()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 87
      (_x.hasTwist, _x.twist.linear.x, _x.twist.linear.y, _x.twist.linear.z, _x.twist.angular.x, _x.twist.angular.y, _x.twist.angular.z, _x.hasAltd, _x.altd, _x.hasMaxAltd, _x.MaxAltd, _x.hasMinAltd, _x.MixAltd, _x.hasYaw, _x.yaw, _x.hasHorizontal, _x.horizontalX, _x.horizontalY, _x.hasFace, _x.tagNr, _x.hasRelease, _x.hasSearch, _x.hasApproach, _x.hasNavigate,) = _struct_B6dBiBiBiBiB2iBi4B.unpack(str[start:end])
      self.hasTwist = bool(self.hasTwist)
      self.hasAltd = bool(self.hasAltd)
      self.hasMaxAltd = bool(self.hasMaxAltd)
      self.hasMinAltd = bool(self.hasMinAltd)
      self.hasYaw = bool(self.hasYaw)
      self.hasHorizontal = bool(self.hasHorizontal)
      self.hasFace = bool(self.hasFace)
      self.hasRelease = bool(self.hasRelease)
      self.hasSearch = bool(self.hasSearch)
      self.hasApproach = bool(self.hasApproach)
      self.hasNavigate = bool(self.hasNavigate)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.nav_XYZ_RxRyRz = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 10
      (_x.hasYawSpeed, _x.yawSpeed, _x.hasHrzSpeed, _x.hrzSpeed,) = _struct_BiBi.unpack(str[start:end])
      self.hasYawSpeed = bool(self.hasYawSpeed)
      self.hasHrzSpeed = bool(self.hasHrzSpeed)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_B6dBiBiBiBiB2iBi4B.pack(_x.hasTwist, _x.twist.linear.x, _x.twist.linear.y, _x.twist.linear.z, _x.twist.angular.x, _x.twist.angular.y, _x.twist.angular.z, _x.hasAltd, _x.altd, _x.hasMaxAltd, _x.MaxAltd, _x.hasMinAltd, _x.MixAltd, _x.hasYaw, _x.yaw, _x.hasHorizontal, _x.horizontalX, _x.horizontalY, _x.hasFace, _x.tagNr, _x.hasRelease, _x.hasSearch, _x.hasApproach, _x.hasNavigate))
      length = len(self.nav_XYZ_RxRyRz)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.nav_XYZ_RxRyRz.tostring())
      _x = self
      buff.write(_struct_BiBi.pack(_x.hasYawSpeed, _x.yawSpeed, _x.hasHrzSpeed, _x.hrzSpeed))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.twist is None:
        self.twist = geometry_msgs.msg.Twist()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 87
      (_x.hasTwist, _x.twist.linear.x, _x.twist.linear.y, _x.twist.linear.z, _x.twist.angular.x, _x.twist.angular.y, _x.twist.angular.z, _x.hasAltd, _x.altd, _x.hasMaxAltd, _x.MaxAltd, _x.hasMinAltd, _x.MixAltd, _x.hasYaw, _x.yaw, _x.hasHorizontal, _x.horizontalX, _x.horizontalY, _x.hasFace, _x.tagNr, _x.hasRelease, _x.hasSearch, _x.hasApproach, _x.hasNavigate,) = _struct_B6dBiBiBiBiB2iBi4B.unpack(str[start:end])
      self.hasTwist = bool(self.hasTwist)
      self.hasAltd = bool(self.hasAltd)
      self.hasMaxAltd = bool(self.hasMaxAltd)
      self.hasMinAltd = bool(self.hasMinAltd)
      self.hasYaw = bool(self.hasYaw)
      self.hasHorizontal = bool(self.hasHorizontal)
      self.hasFace = bool(self.hasFace)
      self.hasRelease = bool(self.hasRelease)
      self.hasSearch = bool(self.hasSearch)
      self.hasApproach = bool(self.hasApproach)
      self.hasNavigate = bool(self.hasNavigate)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.nav_XYZ_RxRyRz = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      _x = self
      start = end
      end += 10
      (_x.hasYawSpeed, _x.yawSpeed, _x.hasHrzSpeed, _x.hrzSpeed,) = _struct_BiBi.unpack(str[start:end])
      self.hasYawSpeed = bool(self.hasYawSpeed)
      self.hasHrzSpeed = bool(self.hasHrzSpeed)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_BiBi = struct.Struct("<BiBi")
_struct_3I = struct.Struct("<3I")
_struct_B6dBiBiBiBiB2iBi4B = struct.Struct("<B6dBiBiBiBiB2iBi4B")
